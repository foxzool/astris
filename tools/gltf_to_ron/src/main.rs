use std::env;
use std::error::Error;
use std::fs;
use std::io::{self, Read};
use std::path::{Path, PathBuf};

use glam::{Mat4, Vec3};
use gltf::buffer::Data;
use gltf::scene::Node;
use gltf::Document;
use ron::ser::{to_string_pretty, PrettyConfig};
use serde::Serialize;

#[derive(Debug, Serialize)]
struct ModelConfig {
    source: String,
    animations: Vec<AnimationConfig>,
    bounding_box: BoundingBox,
}

#[derive(Debug, Serialize)]
struct AnimationConfig {
    name: String,
    index: usize,
    resource_path: String,
    duration_seconds: f32,
}

#[derive(Debug, Serialize, Clone)]
struct BoundingBox {
    min: [f32; 3],
    max: [f32; 3],
}

impl BoundingBox {
    fn from_point(point: Vec3) -> Self {
        let array = point.to_array();
        Self {
            min: array,
            max: array,
        }
    }

    fn include_point(&mut self, point: Vec3) {
        let array = point.to_array();
        for ((min, max), component) in self.min.iter_mut().zip(self.max.iter_mut()).zip(array) {
            *min = (*min).min(component);
            *max = (*max).max(component);
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args: Vec<_> = env::args().skip(1).collect();

    match args.as_slice() {
        [] => {
            let default_dir = default_assets_dir();
            process_path(default_dir, None)?;
        }
        [input] => {
            process_path(PathBuf::from(input), None)?;
        }
        [input, output] => {
            process_path(PathBuf::from(input), Some(PathBuf::from(output)))?;
        }
        _ => {
            return Err("Usage: gltf_to_ron [input.gltf/glb | directory] [output.ron]".into());
        }
    }

    Ok(())
}

fn process_path(input: PathBuf, explicit_output: Option<PathBuf>) -> Result<(), Box<dyn Error>> {
    if input.is_dir() {
        if explicit_output.is_some() {
            return Err(format!(
                "Cannot specify an explicit output file when processing a directory: {}",
                input.display()
            )
            .into());
        }
        process_directory(&input)?;
    } else if input.is_file() {
        let output = explicit_output.unwrap_or_else(|| input.with_extension("ron"));
        process_file(&input, &output)?;
    } else {
        return Err(format!("Input path does not exist: {}", input.display()).into());
    }

    Ok(())
}

fn process_directory(dir: &Path) -> Result<(), Box<dyn Error>> {
    let mut gltf_files = Vec::new();
    collect_gltf_files(dir, &mut gltf_files)?;
    gltf_files.sort();

    if gltf_files.is_empty() {
        return Err(format!("No .gltf or .glb files were found under {}", dir.display()).into());
    }

    for file in gltf_files {
        let output = file.with_extension("ron");
        process_file(&file, &output)?;
    }

    Ok(())
}

fn collect_gltf_files(dir: &Path, files: &mut Vec<PathBuf>) -> Result<(), io::Error> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        let file_type = entry.file_type()?;
        if file_type.is_dir() {
            collect_gltf_files(&path, files)?;
        } else if file_type.is_file() && is_gltf_file(&path) {
            files.push(path);
        }
    }

    Ok(())
}

fn is_gltf_file(path: &Path) -> bool {
    path.extension()
        .and_then(|ext| ext.to_str())
        .map(|ext| ext.eq_ignore_ascii_case("gltf") || ext.eq_ignore_ascii_case("glb"))
        .unwrap_or(false)
}

fn process_file(input: &Path, output: &Path) -> Result<(), Box<dyn Error>> {
    ensure_not_lfs_pointer(input)?;

    let (document, buffers, _images) = gltf::import(input)?;

    let source = normalize_path(input);
    let animations = extract_animations(&document, &buffers, &source);
    let bounding_box = extract_bounding_box(&document, &buffers)
        .ok_or("Failed to compute bounding box: no vertex positions found")?;

    let config = ModelConfig {
        source: source.clone(),
        animations,
        bounding_box,
    };

    let mut ron_string = String::from("// Auto-generated by gltf_to_ron\n");
    ron_string.push_str(&to_string_pretty(
        &config,
        PrettyConfig::new()
            .depth_limit(8)
            .separate_tuple_members(true),
    )?);
    ron_string.push('\n');

    if let Some(parent) = output.parent() {
        fs::create_dir_all(parent)?;
    }

    fs::write(output, ron_string)?;
    println!("Wrote {} -> {}", input.display(), output.display());

    Ok(())
}

fn default_assets_dir() -> PathBuf {
    let relative = PathBuf::from("assets");
    if relative.is_dir() {
        relative
    } else {
        let mut absolute = workspace_root();
        absolute.push("assets");
        absolute
    }
}

fn workspace_root() -> PathBuf {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path
}

fn normalize_path(path: &Path) -> String {
    let canonical_path = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());

    let mut workspace = workspace_root();
    workspace = workspace
        .canonicalize()
        .unwrap_or_else(|_| workspace.clone());

    let relative = canonical_path
        .strip_prefix(&workspace)
        .map(|p| p.to_path_buf())
        .unwrap_or(canonical_path);

    relative.to_string_lossy().replace('\\', "/")
}

fn ensure_not_lfs_pointer(path: &Path) -> Result<(), io::Error> {
    let mut file = fs::File::open(path)?;
    let mut buffer = [0u8; 128];
    let read = file.read(&mut buffer)?;
    if buffer[..read].starts_with(b"version https://git-lfs.github.com/spec/v1") {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "input file appears to be a Git LFS pointer; download the actual asset before converting",
        ));
    }
    Ok(())
}

fn extract_animations(document: &Document, buffers: &[Data], source: &str) -> Vec<AnimationConfig> {
    document
        .animations()
        .enumerate()
        .map(|(index, animation)| {
            let name = animation
                .name()
                .map(|s| s.to_string())
                .unwrap_or_else(|| format!("Animation{index}"));
            let duration_seconds = animation_duration(&animation, buffers);
            let resource_path = format!("{source}#Animation{index}");

            AnimationConfig {
                name,
                index,
                resource_path,
                duration_seconds,
            }
        })
        .collect()
}

fn animation_duration(animation: &gltf::Animation, buffers: &[Data]) -> f32 {
    animation
        .samplers()
        .filter_map(|sampler| {
            gltf::accessor::Iter::<f32>::new(sampler.input(), |buffer| {
                Some(&buffers[buffer.index()])
            })
        })
        .flatten()
        .fold(0.0, f32::max)
}

fn extract_bounding_box(document: &Document, buffers: &[Data]) -> Option<BoundingBox> {
    let mut bounding_box: Option<BoundingBox> = None;

    for scene in document.scenes() {
        for node in scene.nodes() {
            accumulate_node(node, Mat4::IDENTITY, buffers, &mut bounding_box);
        }
    }

    bounding_box
}

fn accumulate_node(
    node: Node,
    parent_transform: Mat4,
    buffers: &[Data],
    bounding_box: &mut Option<BoundingBox>,
) {
    let local_matrix = Mat4::from_cols_array_2d(&node.transform().matrix());
    let transform = parent_transform * local_matrix;

    if let Some(mesh) = node.mesh() {
        for primitive in mesh.primitives() {
            let reader = primitive.reader(|buffer| Some(&buffers[buffer.index()]));
            if let Some(positions) = reader.read_positions() {
                for position in positions {
                    let position = transform.transform_point3(Vec3::from_array(position));
                    match bounding_box {
                        Some(bbox) => bbox.include_point(position),
                        None => *bounding_box = Some(BoundingBox::from_point(position)),
                    }
                }
            }
        }
    }

    for child in node.children() {
        accumulate_node(child, transform, buffers, bounding_box);
    }
}
