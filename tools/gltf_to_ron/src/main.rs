use std::env;
use std::error::Error;
use std::fs;
use std::io::{self, Read};
use std::path::{Path, PathBuf};

use glam::{Mat4, Vec3};
use gltf::buffer::Data;
use gltf::scene::Node;
use gltf::Document;
use ron::ser::{to_string_pretty, PrettyConfig};
use serde::Serialize;

#[derive(Debug, Serialize)]
struct ModelConfig {
    source: String,
    animations: Vec<AnimationConfig>,
    bounding_box: BoundingBox,
}

#[derive(Debug, Serialize)]
struct AnimationConfig {
    name: String,
    index: usize,
    resource_path: String,
    duration_seconds: f32,
}

#[derive(Debug, Serialize, Clone)]
struct BoundingBox {
    min: [f32; 3],
    max: [f32; 3],
}

impl BoundingBox {
    fn from_point(point: Vec3) -> Self {
        let array = point.to_array();
        Self {
            min: array,
            max: array,
        }
    }

    fn include_point(&mut self, point: Vec3) {
        let array = point.to_array();
        for ((min, max), component) in self.min.iter_mut().zip(self.max.iter_mut()).zip(array) {
            *min = (*min).min(component);
            *max = (*max).max(component);
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let mut args = env::args().skip(1);
    let input = args
        .next()
        .map(PathBuf::from)
        .ok_or("Usage: gltf_to_ron <input.gltf/glb> [output.ron]")?;
    let output = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| input.with_extension("ron"));

    ensure_not_lfs_pointer(&input)?;

    let (document, buffers, _images) = gltf::import(&input)?;

    let source = normalize_path(&input);
    let animations = extract_animations(&document, &buffers, &source);
    let bounding_box = extract_bounding_box(&document, &buffers)
        .ok_or("Failed to compute bounding box: no vertex positions found")?;

    let config = ModelConfig {
        source: source.clone(),
        animations,
        bounding_box,
    };

    let mut ron_string = String::from("// Auto-generated by gltf_to_ron\n");
    ron_string.push_str(&to_string_pretty(
        &config,
        PrettyConfig::new()
            .depth_limit(8)
            .separate_tuple_members(true),
    )?);
    ron_string.push('\n');

    if let Some(parent) = output.parent() {
        fs::create_dir_all(parent)?;
    }

    fs::write(&output, ron_string)?;
    println!("Wrote {}", output.display());

    Ok(())
}

fn normalize_path(path: &Path) -> String {
    path.to_string_lossy().replace('\\', "/")
}

fn ensure_not_lfs_pointer(path: &Path) -> Result<(), io::Error> {
    let mut file = fs::File::open(path)?;
    let mut buffer = [0u8; 128];
    let read = file.read(&mut buffer)?;
    if buffer[..read].starts_with(b"version https://git-lfs.github.com/spec/v1") {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "input file appears to be a Git LFS pointer; download the actual asset before converting",
        ));
    }
    Ok(())
}

fn extract_animations(document: &Document, buffers: &[Data], source: &str) -> Vec<AnimationConfig> {
    document
        .animations()
        .enumerate()
        .map(|(index, animation)| {
            let name = animation
                .name()
                .map(|s| s.to_string())
                .unwrap_or_else(|| format!("Animation{index}"));
            let duration_seconds = animation_duration(&animation, buffers);
            let resource_path = format!("{source}#Animation{index}");

            AnimationConfig {
                name,
                index,
                resource_path,
                duration_seconds,
            }
        })
        .collect()
}

fn animation_duration(animation: &gltf::Animation, buffers: &[Data]) -> f32 {
    animation
        .samplers()
        .filter_map(|sampler| {
            gltf::accessor::Iter::<f32>::new(sampler.input(), |buffer| {
                Some(&buffers[buffer.index()])
            })
        })
        .flatten()
        .fold(0.0, f32::max)
}

fn extract_bounding_box(document: &Document, buffers: &[Data]) -> Option<BoundingBox> {
    let mut bounding_box: Option<BoundingBox> = None;

    for scene in document.scenes() {
        for node in scene.nodes() {
            accumulate_node(node, Mat4::IDENTITY, buffers, &mut bounding_box);
        }
    }

    bounding_box
}

fn accumulate_node(
    node: Node,
    parent_transform: Mat4,
    buffers: &[Data],
    bounding_box: &mut Option<BoundingBox>,
) {
    let local_matrix = Mat4::from_cols_array_2d(&node.transform().matrix());
    let transform = parent_transform * local_matrix;

    if let Some(mesh) = node.mesh() {
        for primitive in mesh.primitives() {
            let reader = primitive.reader(|buffer| Some(&buffers[buffer.index()]));
            if let Some(positions) = reader.read_positions() {
                for position in positions {
                    let position = transform.transform_point3(Vec3::from_array(position));
                    match bounding_box {
                        Some(bbox) => bbox.include_point(position),
                        None => *bounding_box = Some(BoundingBox::from_point(position)),
                    }
                }
            }
        }
    }

    for child in node.children() {
        accumulate_node(child, transform, buffers, bounding_box);
    }
}
